```{r rsetup}
options(stringsAsFactors=FALSE)
require(GenomicRanges)
require(ggplot2)
require(affy)
```

```{r functionDef}
probeClass <- function(probeIDs){
	sapply(strsplit(probeIDs, ".", fixed=T), function(y){y[1]})
}
```

# Examine Results

## Read in the Saccharomyces cerevisiae data and see what we have

```{r loadSc}

seqLoc <- readBamGappedAlignments("seqData/mappedSequences_sc3.bam", use.names=T)

classSeq <- sapply(strsplit(names(seqLoc), ".", fixed=T), function(x){x[1]})
sum(classSeq == "mm")
```

There is only `r sum(classSeq == "mm")` mismatch probe that aligns to the genome for yeast, so we will ignore yeast from further analysis.

## Check all organisms

```{r countAll}
allFile <- dir('seqData/')
bamFile <- grep(".bam", allFile, fixed=T, value=T)
allData <- lapply(bamFile, function(x){
	tmpSeq <- readGappedAlignments(file.path("seqData", x), use.names=T)
	nAlign <- length(names(tmpSeq))
	uniqProbes <- unique(names(tmpSeq))
	probeClass <- sapply(strsplit(uniqProbes, ".", fixed=T), function(y){y[1]})
	nPM <- sum(probeClass == "pm") # number of PM probes that align
	nMM <- sum(probeClass == "mm") # number of MM probes that align
	
	# remove duplicates first
	allProbes <- names(tmpSeq)
	dupProbes <- unique(allProbes[duplicated(allProbes)])
	
	dupFile <- paste(strsplit(x, ".", fixed=T)[[1]][1], "_multMatch.txt", sep="", collapse="")
	cat(dupProbes, file=file.path("seqData", dupFile), sep="\n")
	
	dupClass <- sapply(strsplit(dupProbes, ".", fixed=T), function(y){y[1]})
	dupPM <- sum(dupClass == "pm")
	dupMM <- sum(dupClass == "mm")
	
	nonDup <- allProbes[!(allProbes %in% dupProbes)]
	nonClass <- sapply(strsplit(nonDup, ".", fixed=T), function(y){y[1]})
	nonPM <- sum(nonClass == "pm")
	nonMM <- sum(nonClass == "mm")
	return(c(nPM=nPM, nMM=nMM, dupPM=dupPM, dupMM=dupMM, nonPM=nonPM, nonMM=nonMM))
})
names(allData) <- bamFile
allData
```

So we can basically ignore yeast. However, everything else it looks like we get *some* **MM** alignments. What kinds of questions can we ask with this data?

 * For those **PM** that don't map uniquely, what is the distribution of the # of matches?
 * Same question for the **MM** probes
 * How many **PM** have associated **MM** with perfect matches elsewhere in the genome?
   * How does that change between those **PM** that map uniquely and those that are duplicates?
   * Do those **PM** with **MM** that map to genome have higher intensities?
     * This will require loading multiple **CEL** files for the chip. -> which ones should we use? Should we just take a random sample of the ones available, i.e. one from each condition in a GSE across multiple GSE's??
     * Should we restrict this to **PM** and **MM** that map to exons?
 * Restricting to those probes that map uniquely:
   * Making new probesets based on Refseq, and requiring a minimum of 3 probes per transcript:
     * Again, do we restrict to just exons?
     * How many probesets do we get based on just **PM** probes?
     * How many probesets do we get when including **MM** probes?
     * How many probesets change their composition when **MM** probes are allowed?
     * How do diff. gene results change when **MM** probes are included?
     
## Answer questions above

```{r examinData}
useData <- c("dm3", "dr6", "xtropicalis", "rn4", "hg19", "mm9", "mm10", "ce6")
celLoc <- c(hg19="hs", mm9="mm", mm10="mm", rn4="rn", dr6="dr", dm3="dm", ce6="ce", xtropicalis="xt")

allData <- lapply(useData, function(inData){
	inData <- "dm3" #testing purposes
	{# grab the data we need
	bamFile <- paste("mappedSequences_", inData, ".bam", sep="", collapse="")
	probeAlign <- readGappedAlignments(file.path("seqData", bamFile), use.names=T)
	probeAlign <- as(probeAlign, "GRanges")
	probeNames <- names(probeAlign)
	pClass <- probeClass(probeNames)
	elementMetadata(probeAlign) <- data.frame(probeNames=probeNames, class=pClass) # put probe IDs in here so they don't become mangled
	names(probeAlign) <- NULL
	affyCntr <- unique(grep("AFFX", probeNames, value=T))
	keepSeq <- which(!(probeNames %in% affyCntr))
	probeAlign <- probeAlign[keepSeq] 
		
	rm(bamFile, probeNames, pClass, affyCntr, keepSeq)
	}
	
	# commented code chunks that may be useful later
	{ 
# 	mStatus <- duplicated(probeNames)
# 	multProbes <- unique(probeNames[mStatus]) # those probes aligning to multiple locations in the genome
# 	
# 	singProbes <- unique(probeNames[!mStatus])
# 	singSeq <- tmpSeq[which(!mStatus)]
# 	
# 	multClass <- probeClass(multProbes)
# 	pmMult <- multProbes[multClass == "pm"]
# 	mmMult <- multProbes[multClass == "mm"]
	
# 	pmMultCnt <- sapply(pmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	mmMultCnt <- sapply(mmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	multCnt <- data.frame(cnt=c(pmMultCnt, mmMultCnt), class=c(rep("pm", length(pmMultCnt)), rep("mm", length(mmMultCnt))))
# 	
# 	trimMult <- multCnt[multCnt[,1] <= 10,]
# 	cntMM <- hist(trimMult$cnt[trimMult$class == "mm"], breaks=10, plot=F)
# 	cntPM <- hist(trimMult$cnt[trimMult$class == "pm"], breaks=10, plot=F)
	
	# ggplot(trimMult, aes(x=cnt, colour=class)) + geom_density() + xlim(0, 10)
	
	# because the mm matches are much fewer, it makes far more sense to reverse the question of associations between PM and MM probes, and ask how many of the MM probes that map to the genome have an associated PM match?
	}
	
	# new variables kept: probeAlign
	
	###
	## For each mm probe that had an alignment to the genome, find the associated
	## pm probe and count for both of them how many alignments they had.
	
	# For everything: count the number of alignments to the genome
	{
		probeNames <- elementMetadata(probeAlign)$probeNames
		allClass <- elementMetadata(probeAlign)$class
		mmAlign <- unique(probeNames[allClass == "mm"])
		mmAlignIndx <- lapply(mmAlign, function(x){which(probeNames %in% x)})
		
		mmAlignSplit <- strsplit(mmAlign, ".", fixed=T)
		pmAlign <- sapply(mmAlignSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmAlignIndx <- lapply(pmAlign, function(x){which(probeNames %in% x)})
		
		allCnts <- data.frame(pm=(sapply(pmAlignIndx, length)), mm=(sapply(mmAlignIndx, length)),
													mmProbe=mmAlign, pmProbe=pmAlign)
		rownames(allCnts) <- NULL
		
		rm(allClass, mmAlign, mmAlignIndx, mmAlignSplit, pmAlign, pmAlignIndx)
	}
	
	# New variables kept: probeAlign, allCnts
	
	# restrict to those probes that align to exons
	# Note that these exons are artificial, created using mergeBED to get essentially transcribed regions inside of known genes
	{
		exonFile <- paste(inData, "_mergeExons.bed.gz", sep="", collapse="")
		useExons <- read.table(file.path("seqData", exonFile), sep="\t")
		exonIntervals <- GRanges(seqnames=Rle(useExons[,1]), ranges=IRanges(useExons[,2], useExons[,3]),
											 strand=Rle(useExons[,4]))
		
		exonOverlaps <- subsetByOverlaps(query=probeAlign, subject=exonIntervals, minoverlap=23, type="any")
		
		hasExonProbes <- elementMetadata(exonOverlaps)$probeNames
		exonProbeClass <- elementMetadata(exonOverlaps)$class
		
		mmExons <- unique(hasExonProbes[exonProbeClass == "mm"])
		mmIntIndx <- sapply(mmExons, function(x){which(hasExonProbes %in% x)})
		# figure out the associated PM probes
		mmSplit <- strsplit(mmExons, ".", fixed=T)
		pmExons <- sapply(mmSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmIntIndx <- lapply(pmExons, function(x){which(hasExonProbes %in% x)})
		
		exonCnts <- data.frame(pm=(sapply(pmIntIndx, length)), mm=(sapply(mmIntIndx, length)),
													 mmProbe=mmExons, pmProbe=pmExons)
		rownames(exonCnts) <- NULL
		
		allCnts <- merge(allCnts, exonCnts, by=c("pmProbe", "mmProbe"), all=T, suffixes=c(".A", ".E"))
		
		rm(exonFile, useExons, exonOverlaps, hasExonProbes, exonProbeClass,
			 mmExons, mmIntIndx, mmSplit, pmExons, pmIntIndx, exonCnts)
	}
	
	# new variables: probeAlign, allCnts, exonIntervals
	
	## Load up the experimental data and rename
	{
		useCel <- file.path("randomCels", celLoc[inData])
		celDat <- ReadAffy(celfile.path=useCel)
		
		bCel <- bg.correct.mas(celDat)
		
		pmIndx <- indexProbes(bCel, which="pm")
		mmIndx <- indexProbes(bCel, which="mm")
		useP <- names(pmIndx)
		
		lenP <- sapply(pmIndx, length) # how many probes in each probeset
		pName <- rep(useP, lenP)
		pmIndx <- unlist(pmIndx, use.names=F)
		pmXY <- indices2xy(pmIndx, abatch=bCel)
		mmIndx <- unlist(mmIndx, use.names=F)
		mmXY <- indices2xy(mmIndx, abatch=bCel)
		
		pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
		mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")
		
		probeNames <- c(pmName, mmName)
		orgName <- c(pmIndx, mmIndx)
		
		nameReord <- order(orgName)
		orgName <- orgName[nameReord]
		probeNames <- probeNames[nameReord]
	
		pIntensity <- rbind(pm(bCel), mm(bCel))
		pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]
	
		all.equal(as.integer(rownames(pIntensity)), orgName)
		rownames(pIntensity) <- probeNames
	
		pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
		n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
		pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]
		
		n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
		pIntensity <- pIntensity[n.affyCtrl,]
		
		indx2Name <- data.frame(indx=orgName, name=probeNames)
		
		rm(celDat, n.affyCtrl, probeNames, orgName, pmName, mmName, useP,
			 lenP, pName, pmIndx, pmXY, mmIndx, mmXY, nameReord)
	}
	
	# new variables: indx2name, pIntensity, pm.mm.Corr, bCel
	
	# calculate how many negatives are the result of mm aligning in genome
	{
		pm.mm.Diff <- pIntensity[pm.mm.Corr$pm,] - pIntensity[pm.mm.Corr$mm,]
		sumNeg <- apply(pm.mm.Diff, 1, function(x){sum(x < 0)})
		
		minSum <- 9
		if (inData == "xtropicalis"){
			minSum <- 2
		}
		
		isNeg <- sumNeg >= minSum
		sum(isNeg) / nrow(pm.mm.Corr)
		pmNeg <- rownames(pm.mm.Diff[isNeg,])
		# of those that show *some* negatives, how many are in our probe lists based on *MM* alignments?
		allPM.fromMM <- allCnts$pmProbe
		nallPM <- length(allPM.fromMM)
		nallPM.inNeg <- sum(allPM.fromMM %in% pmNeg) 
		
		# and just those where the *MM* aligns to an exon?
		fromExon <- !(is.na(allCnts$pm.E))
		allPM.fromExon <- allCnts$pmProbe[fromExon]
		nallPM.Exon <- length(allPM.fromExon)
		nallPM.Exon.inNeg <- sum(allPM.fromExon %in% pmNeg)
		
		allMM.fromExon <- allCnts$mmProbe[fromExon]
		
		outDat <- c(nallPM=nallPM, nallPM.inNeg=nallPM.inNeg, nallPM.Exon=nallPM.Exon, nallPm.Exon.inNeg=nallPM.Exon.inNeg)
		
		rm(sumNeg, minSum, isNeg, pmNeg, allPM.fromMM, nallPM, nallPM.inNeg, fromExon,
		 allPM.fromExon, allPM.fromMM, allMM.fromExon, nallPM.Exon, nallPM.Exon.inNeg)
	}
	
	
	
	# new variables are: outDat, pm.mm.Diff
	
	# and what about the distribution of MM intensities?
	nSamp <- 10000
	allMMInt <- log2(as.vector(pIntensity[pm.mm.Corr$mm,]))
	allMMInt <- sample(allMMInt, nSamp)
	allPMInt <- log2(as.vector(pIntensity[pm.mm.Corr$pm,]))
	allPMInt <- sample(allPMInt, nSamp)
	allInt <- data.frame(probeInt=c(allMMInt, allPMInt), probeType=c(rep("mm.all", length(allMMInt)), rep("pm.all", length(allPMInt))) )
	
	mm.probeInt <- log2(as.vector(pIntensity[allMM.fromExon,]))
	pm.probeInt <- log2(as.vector(pIntensity[allPM.fromExon,]))
	useInt <- data.frame(probeInt=c(mm.probeInt, pm.probeInt), probeType=c(rep("mm.exon", length(mm.probeInt)),
																																				 rep("pm.exon", length(mm.probeInt))))
	
	plotInt <- rbind(allInt, useInt)
	outPlotAllExp <- ggplot(plotInt, aes(x=probeInt, colour=probeType)) + geom_density() + labs(title=inData)
	
	# For those MM probes that overlap with exons, find the biggest PM - MM difference 
	# and examine some properties
	exonDat <- tmpDat[!(is.na(tmpDat$pm.E)),]
	exonSingleMM <- (exonDat$mm.E == 1) & (exonDat$pm.E == 1) # start with those
	exonDatSingleMM <- exonDat[exonSingleMM,]
	exonSingleDifs <- pm.mm.Diff[(exonDat$pmProbe[exonSingleMM]),]
	
	useMin <- which.min(exonSingleDifs)
	r = ((useMin-1) %% nrow(exonSingleDifs)) + 1
	c = floor((useMin-1) / nrow(exonSingleDifs)) + 1
	
	probeSetP <- strsplit(rownames(exonSingleDifs)[r], ".", fixed=T)
	probeSetP <- probeSetP[[1]][2]
	useProbes <- grep(probeSetP, rownames(pIntensity), value=T)
	probeSetInt <- pIntensity[useProbes, c]
	probeSetInt <- data.frame(intensity=(probeSetInt), probeID=names(probeSetInt),
														probeClass=probeClass(names(probeSetInt)))
	
	
	investigateProbes <- c(exonDatSingleMM$pmProbe[r], exonDatSingleMM$mmProbe[r])
	useProbes <- which(!(rownames(probeSetInt) %in% investigateProbes))
	
	probeSetDen <- probeSetInt[useProbes,]
	investigateInt <- probeSetInt[-useProbes,]
	
	investigateInt$y <- 0
	
	# this looks at the mm and pm distribution without 
	bl.Plot1 <- ggplot() + geom_histogram(data=probeSetDen, aes(x=intensity, fill=probeClass), alpha=.5, position="identity") + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass), size=3)
	bl.Plot2 <- ggplot() + geom_density(data=probeSetDen, aes(x=intensity, colour=probeClass)) + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass), size=3)
	
	
})

```

This gives the **MM** probes that aligned (either exons or anywhere), as well as the associated **PM** probes, and the number of alignments. For each of the organisms, we will load 20 randomly selected **CEL** files and examine both the **PM** intensities compared to **MM** for those that did and did not align to exons, and examine the distribution of intensities of all **MM** probes and locate the aligned uniquely **MM** probes in the distribution.

```{r intensityComparison}

useDatNames <- names(allData)

denData <- lapply(useDatNames, function(inOrg){
	tmpDat <- allData[[inOrg]]
	useCel <- file.path("randomCels", celLoc[inOrg])
	celDat <- ReadAffy(celfile.path=useCel)
	
	bCel <- bg.correct.mas(celDat)
	
	rm(celDat)
	
	pmIndx <- indexProbes(bCel, which="pm")
	mmIndx <- indexProbes(bCel, which="mm")
	useP <- names(pmIndx)
	
	lenP <- sapply(pmIndx, length) # how many probes in each probeset
	pName <- rep(useP, lenP)
	pmIndx <- unlist(pmIndx, use.names=F)
	pmXY <- indices2xy(pmIndx, abatch=bCel)
	mmIndx <- unlist(mmIndx, use.names=F)
	mmXY <- indices2xy(mmIndx, abatch=bCel)
	
	pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
	mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")
	
	probeNames <- c(pmName, mmName)
	orgName <- c(pmIndx, mmIndx)
	
	nameReord <- order(orgName)
	orgName <- orgName[nameReord]
	probeNames <- probeNames[nameReord]
	
	pIntensity <- rbind(pm(bCel), mm(bCel))
	pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]
	
	all.equal(as.integer(rownames(pIntensity)), orgName)
	rownames(pIntensity) <- probeNames
	
	pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
	n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
	pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]
	
	n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
	pIntensity <- pIntensity[n.affyCtrl,]
	
	pIntensity.log <- log2(pIntensity)
	pm.mm.Diff <- pIntensity[pm.mm.Corr$pm,] - pIntensity[pm.mm.Corr$mm,]
	sumNeg <- apply(pm.mm.Diff, 1, function(x){sum(x < 0)})
	
	minSum <- 9
	if (inOrg == "xtropicalis"){
		minSum <- 2
	}
	
	isNeg <- sumNeg >= minSum
	sum(isNeg) / nrow(pm.mm.Corr)
	pmNeg <- rownames(pm.mm.Diff[isNeg,])
	# of those that show *some* negatives, how many are in our probe lists based on *MM* alignments?
	allPM.fromMM <- tmpDat$pmProbe
	nallPM <- length(allPM.fromMM)
	nallPM.inNeg <- sum(allPM.fromMM %in% pmNeg) 
	
	# and just those where the *MM* aligns to an exon?
	fromExon <- !(is.na(tmpDat$pm.E))
	allPM.fromExon <- tmpDat$pmProbe[fromExon]
	nallPM.Exon <- length(allPM.fromExon)
	nallPM.Exon.inNeg <- sum(allPM.fromExon %in% pmNeg)
	
	allMM.fromExon <- tmpDat$mmProbe[fromExon]
	
	outDat <- c(nallPM=nallPM, nallPM.inNeg=nallPM.inNeg, nallPM.Exon=nallPM.Exon, nallPm.Exon.inNeg=nallPM.Exon.inNeg)
	
	rm(n.affyCtrl, probeNames, orgName, nameReord, pmIndx, mmIndx)
	
	# and what about the distribution of MM intensities?
	nSamp <- 10000
	allMMInt <- log2(as.vector(pIntensity[pm.mm.Corr$mm,]))
	allMMInt <- sample(allMMInt, nSamp)
	allPMInt <- log2(as.vector(pIntensity[pm.mm.Corr$pm,]))
	allPMInt <- sample(allPMInt, nSamp)
	allInt <- data.frame(probeInt=c(allMMInt, allPMInt), probeType=c(rep("mm.all", length(allMMInt)), rep("pm.all", length(allPMInt))) )
	
	mm.probeInt <- log2(as.vector(pIntensity[allMM.fromExon,]))
	pm.probeInt <- log2(as.vector(pIntensity[allPM.fromExon,]))
	useInt <- data.frame(probeInt=c(mm.probeInt, pm.probeInt), probeType=c(rep("mm.exon", length(mm.probeInt)),
																																				 rep("pm.exon", length(mm.probeInt))))
	
	plotInt <- rbind(allInt, useInt)
	outPlotAllExp <- ggplot(plotInt, aes(x=probeInt, colour=probeType)) + geom_density() + labs(title=inData)
	
	# For those MM probes that overlap with exons, find the biggest PM - MM difference 
	# and examine some properties
	exonDat <- tmpDat[!(is.na(tmpDat$pm.E)),]
	exonSingleMM <- (exonDat$mm.E == 1) & (exonDat$pm.E == 1) # start with those
	exonDatSingleMM <- exonDat[exonSingleMM,]
	exonSingleDifs <- pm.mm.Diff[(exonDat$pmProbe[exonSingleMM]),]
	
	useMin <- which.min(exonSingleDifs)
	r = ((useMin-1) %% nrow(exonSingleDifs)) + 1
	c = floor((useMin-1) / nrow(exonSingleDifs)) + 1
	
	probeSetP <- strsplit(rownames(exonSingleDifs)[r], ".", fixed=T)
	probeSetP <- probeSetP[[1]][2]
	useProbes <- grep(probeSetP, rownames(pIntensity), value=T)
	probeSetInt <- pIntensity[useProbes, c]
	probeSetInt <- data.frame(intensity=(probeSetInt), probeID=names(probeSetInt),
														probeClass=probeClass(names(probeSetInt)))
	
	
	investigateProbes <- c(exonDatSingleMM$pmProbe[r], exonDatSingleMM$mmProbe[r])
	useProbes <- which(!(rownames(probeSetInt) %in% investigateProbes))
	
	probeSetDen <- probeSetInt[useProbes,]
	investigateInt <- probeSetInt[-useProbes,]
	
	investigateInt$y <- 0
	
	# this looks at the mm and pm distribution without 
	bl.Plot1 <- ggplot() + geom_histogram(data=probeSetDen, aes(x=intensity, fill=probeClass), alpha=.5, position="identity") + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass), size=3)
	bl.Plot2 <- ggplot() + geom_density(data=probeSetDen, aes(x=intensity, colour=probeClass)) + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass), size=3)
	
	# now grab all of the probes that align to the same location as the mismatch
	
	
	cdf2Det <- grep("cdf", search(), value=T)
	detach(cdf2Det, character.only=T)
	
	return(list(outDat=outDat, plot=outPlot))
})
.sessionInfo <- sessionInfo()
.datetime <- Sys.time()
save(denData, .sessionInfo, .datetime, file="densityPlotData.RData")
```
     
 To Do: Send Eric links to the 5 human genomes assemblies that we have.
 
 Extra analysis: For each organism, find the biggest negative difference, and for that particular
 experiment and probeset, look at the signal distributions of the PM probes and MM probes (without the MM probe that caused problem), and look at where the MM probe falls in the distribution. How does the summarization value change with and without thise PM-MM pair? 
 Then define a new probeset based on the exon the MM probe aligns to, and look at the PM signal distribution and where the MM probe intensity now falls. What is the summary value for this probeset with and without the MM probe?
 Looking at the five human genomes we have:
 * How does the number of probes that align uniquely change in each class of **PM** and **MM**?
   * i.e. for each probe that has a unique alignment in each version of the genome, track whether it:
     * aligns uniquely, aligns non-uniquely, or does not align in each of the other genomes
   * How do we summarize this information in a useful manner?
     * Venn diagrams??