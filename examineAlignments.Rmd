```{r rsetup}
options(save.defaults=list(compress="xz"), stringsAsFactors=FALSE)
require(GenomicRanges)
require(ggplot2)
require(affy)
```

```{r functionDef}
probeClass <- function(probeIDs){
	sapply(strsplit(probeIDs, ".", fixed=T), function(y){y[1]})
}
```

# Examine Results

## Read in the Saccharomyces cerevisiae data and see what we have

```{r loadSc}

seqLoc <- readBamGappedAlignments("seqData/mappedSequences_sc3.bam", use.names=T)

classSeq <- sapply(strsplit(names(seqLoc), ".", fixed=T), function(x){x[1]})
sum(classSeq == "mm")
```

There is only `r sum(classSeq == "mm")` mismatch probe that aligns to the genome for yeast, so we will ignore yeast from further analysis.

## Check all organisms

```{r countAll}
allFile <- dir('seqData/')
bamFile <- grep(".bam", allFile, fixed=T, value=T)
allData <- lapply(bamFile, function(x){
	tmpSeq <- readBamGappedAlignments(file.path("seqData", x), use.names=T)
	nAlign <- length(names(tmpSeq))
	uniqProbes <- unique(names(tmpSeq))
	probeClass <- sapply(strsplit(uniqProbes, ".", fixed=T), function(y){y[1]})
	nPM <- sum(probeClass == "pm") # number of PM probes that align
	nMM <- sum(probeClass == "mm") # number of MM probes that align
	
	# remove duplicates first
	allProbes <- names(tmpSeq)
	dupProbes <- unique(allProbes[duplicated(allProbes)])
	
	dupFile <- paste(strsplit(x, ".", fixed=T)[[1]][1], "_multMatch.txt", sep="", collapse="")
	cat(dupProbes, file=file.path("seqData", dupFile), sep="\n")
	
	dupClass <- sapply(strsplit(dupProbes, ".", fixed=T), function(y){y[1]})
	dupPM <- sum(dupClass == "pm")
	dupMM <- sum(dupClass == "mm")
	
	nonDup <- allProbes[!(allProbes %in% dupProbes)]
	nonClass <- sapply(strsplit(nonDup, ".", fixed=T), function(y){y[1]})
	nonPM <- sum(nonClass == "pm")
	nonMM <- sum(nonClass == "mm")
	return(c(nPM=nPM, nMM=nMM, dupPM=dupPM, dupMM=dupMM, nonPM=nonPM, nonMM=nonMM))
})
names(allData) <- bamFile
allData
```

So we can basically ignore yeast. However, everything else it looks like we get *some* **MM** alignments. What kinds of questions can we ask with this data?

 * For those **PM** that don't map uniquely, what is the distribution of the # of matches?
 * Same question for the **MM** probes
 * How many **PM** have associated **MM** with perfect matches elsewhere in the genome?
   * How does that change between those **PM** that map uniquely and those that are duplicates?
   * Do those **PM** with **MM** that map to genome have higher intensities?
     * This will require loading multiple **CEL** files for the chip. -> which ones should we use? Should we just take a random sample of the ones available, i.e. one from each condition in a GSE across multiple GSE's??
     * Should we restrict this to **PM** and **MM** that map to exons?
 * Restricting to those probes that map uniquely:
   * Making new probesets based on Refseq, and requiring a minimum of 3 probes per transcript:
     * Again, do we restrict to just exons?
     * How many probesets do we get based on just **PM** probes?
     * How many probesets do we get when including **MM** probes?
     * How many probesets change their composition when **MM** probes are allowed?
     * How do diff. gene results change when **MM** probes are included?
     
## Answer questions above

```{r useOrgs}
useData <- c("rn4", "hg19", "mm9", "mm10", "ce6", "dm3", "dr6")
allData <- lapply(useData, function(inData){
	bamFile <- paste("mappedSequences_", inData, ".bam", sep="", collapse="")
	tmpSeq <- readGappedAlignments(file.path("seqData", bamFile), use.names=T)
	tmpSeq <- as(tmpSeq, "GRanges")
	probeNames <- names(tmpSeq)
	pClass <- probeClass(probeNames)
	elementMetadata(tmpSeq) <- data.frame(probeNames=names(tmpSeq), class=pClass) # put probe IDs in here so they don't become mangled
	names(tmpSeq) <- NULL
	affyCntr <- unique(grep("AFFX", probeNames, value=T))
	keepSeq <- which(!(probeNames %in% affyCntr))
	probeNames <- probeNames[keepSeq]
	tmpSeq <- tmpSeq[keepSeq] 
	nProbes <- length(probeNames)
	
	mStatus <- duplicated(probeNames)
	multProbes <- unique(probeNames[mStatus]) # those probes aligning to multiple locations in the genome
	
	singProbes <- unique(probeNames[!mStatus])
	singSeq <- tmpSeq[which(!mStatus)]
	
	multClass <- probeClass(multProbes)
	pmMult <- multProbes[multClass == "pm"]
	mmMult <- multProbes[multClass == "mm"]
	
# 	pmMultCnt <- sapply(pmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	mmMultCnt <- sapply(mmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	multCnt <- data.frame(cnt=c(pmMultCnt, mmMultCnt), class=c(rep("pm", length(pmMultCnt)), rep("mm", length(mmMultCnt))))
# 	
# 	trimMult <- multCnt[multCnt[,1] <= 10,]
# 	cntMM <- hist(trimMult$cnt[trimMult$class == "mm"], breaks=10, plot=F)
# 	cntPM <- hist(trimMult$cnt[trimMult$class == "pm"], breaks=10, plot=F)
	
	# ggplot(trimMult, aes(x=cnt, colour=class)) + geom_density() + xlim(0, 10)
	
	# because the mm matches are much fewer, it makes far more sense to reverse the question of associations between PM and MM probes, and ask how many of the MM probes that map to the genome have an associated PM match?
	
	# what about if we don't restrict to exons
	allStatus <- elementMetadata(tmpSeq)$class
	mmAlign <- unique(probeNames[allStatus == "mm"])
	mmAlignIndx <- lapply(mmAlign, function(x){which(probeNames %in% x)})
	
	mmAlignSplit <- strsplit(mmAlign, ".", fixed=T)
	pmAlign <- sapply(mmAlignSplit, function(inMM){
		nEl <- length(inMM)
		pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
		paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
	})
	
	pmAlignIndx <- lapply(pmAlign, function(x){which(probeNames %in% x)})
	
	allCnts <- data.frame(pm=(sapply(pmAlignIndx, length)), mm=(sapply(mmAlignIndx, length)),
												mmProbe=mmAlign, pmProbe=pmAlign)
	rownames(allCnts) <- NULL
		
	# restrict to those probes that align to exons
	## Note that these exons are artificial, created using mergeBED to get essentially transcribed regions
	exonFile <- paste(inData, "_mergeExons.bed.gz", sep="", collapse="")
	useExons <- read.table(file.path("seqData", exonFile), sep="\t")
	exonInt <- GRanges(seqnames=Rle(useExons[,1]), ranges=IRanges(useExons[,2], useExons[,3]),
										 strand=Rle(useExons[,4]))
	
	exonOverlaps <- subsetByOverlaps(query=tmpSeq, subject=exonInt, minoverlap=23, type="any")
	
	hasExonProbes <- elementMetadata(exonOverlaps)$probeNames
	exonProbeClass <- elementMetadata(exonOverlaps)$class
	
	mmExons <- unique(hasExonProbes[exonProbeClass == "mm"])
	mmIntIndx <- sapply(mmExons, function(x){which(hasExonProbes %in% x)})
	# figure out the associated PM probes
	mmSplit <- strsplit(mmExons, ".", fixed=T)
	pmExons <- sapply(mmSplit, function(inMM){
		nEl <- length(inMM)
		pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
		paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
	})
	
	pmIntIndx <- lapply(pmExons, function(x){which(hasExonProbes %in% x)})
	
	exonCnts <- data.frame(pm=(sapply(pmIntIndx, length)), mm=(sapply(mmIntIndx, length)),
												 mmProbe=mmExons, pmProbe=pmExons)
	rownames(exonCnts) <- NULL
	
	allCnts <- merge(allCnts, exonCnts, by=c("pmProbe", "mmProbe"), all=T, suffixes=c(".A", ".E"))
		
	return(allCnts)
})
names(allData) <- useData
.sessionInfo <- sessionInfo()
.datetime <- Sys.time()
save(list=c(".sessionInfo", ".datetime", "allData"), file="allData_mmResults.RData")
```

This gives the **MM** probes that aligned (either exons or anywhere), as well as the associated **PM** probes, and the number of alignments. For each of the organisms, we will load 20 randomly selected **CEL** files and examine both the **PM** intensities compared to **MM** for those that did and did not align to exons, and examine the distribution of intensities of all **MM** probes and locate the aligned uniquely **MM** probes in the distribution.

```{r intensityComparison}
celLoc <- c(hg19="hs", mm9="mm", mm10="mm", rn4="rn", dr6="dr", dm3="dm", ce6="ce")
useDatNames <- names(allData)

lapply(useDatNames, function(inOrg){
	tmpDat <- allData[[inOrg]]
	useCel <- file.path("randomCels", celLoc[inOrg])
	celDat <- ReadAffy(celfile.path=useCel)
	
	bCel <- bg.correct.mas(celDat)
	
	rm(celDat)
	
	pmIndx <- indexProbes(bCel, which="pm")
	mmIndx <- indexProbes(bCel, which="mm")
	useP <- names(pmIndx)
	
	lenP <- sapply(pmIndx, length) # how many probes in each probeset
	pName <- rep(useP, lenP)
	pmIndx <- unlist(pmIndx, use.names=F)
	pmXY <- indices2xy(pmIndx, abatch=bCel)
	mmIndx <- unlist(mmIndx, use.names=F)
	mmXY <- indices2xy(mmIndx, abatch=bCel)
	
	pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
	mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")
	
	probeNames <- c(pmName, mmName)
	orgName <- c(pmIndx, mmIndx)
	
	nameReord <- order(orgName)
	orgName <- orgName[nameReord]
	probeNames <- probeNames[nameReord]
	
	pIntensity <- rbind(pm(bCel), mm(bCel))
	pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]
	
	all.equal(as.integer(rownames(pIntensity)), orgName)
	rownames(pIntensity) <- probeNames
	
	pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
	n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
	pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]
	
	n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
	pIntensity <- pIntensity[n.affyCtrl,]
	
	pIntensity.log <- log2(pIntensity)
	pm.mm.Diff <- pIntensity[pm.mm.Corr$pm,] - pIntensity[pm.mm.Corr$mm,]
	sumNeg <- apply(pm.mm.Diff, 1, function(x){sum(x < 0)})
	
	isNeg <- sumNeg >= 9
	sum(isNeg) / nrow(pm.mm.Corr)
	pmNeg <- rownames(pm.mm.Diff[isNeg,])
	# of those that show *some* negatives, how many are in our probe lists based on *MM* alignments?
	allPM.fromMM <- tmpDat$pmProbe
	nallPM <- length(allPM.fromMM)
	nallPM.inNeg <- sum(allPM.fromMM %in% pmNeg) 
	
	# and just those where the *MM* aligns to an exon?
	fromExon <- !(is.na(tmpDat$pm.E))
	allPM.fromExon <- tmpDat$pmProbe[fromExon]
	nallPM.Exon <- length(allPM.fromExon)
	nallPM.Exon.inNeg <- sum(allPM.fromExon %in% pmNeg)
	
	allMM.fromExon <- tmpDat$mmProbe[fromExon]
	
	outDat <- c(nallPM=nallPM, nallPM.inNeg=nallPM.inNeg, nallPM.Exon=nallPM.Exon, nallPm.Exon.inNeg=nallPM.Exon.inNeg)
	
	rm(pm.mm.Diff, n.affyCtrl, probeNames, orgName, nameReord, pmIndx, mmIndx)
	
	# and what about the distribution of MM intensities?
	nSamp <- 10000
	allMMInt <- log2(as.vector(pIntensity[pm.mm.Corr$mm,]))
	allMMInt <- sample(allMMInt, nSamp)
	allPMInt <- log2(as.vector(pIntensity[pm.mm.Corr$pm,]))
	allPMInt <- sample(allPMInt, nSamp)
	allInt <- data.frame(probeInt=c(allMMInt, allPMInt), probeType=c(rep("mm.all", length(allMMInt)), rep("pm.all", length(allPMInt))) )
	
	mm.probeInt <- log2(as.vector(pIntensity[allMM.fromExon,]))
	pm.probeInt <- log2(as.vector(pIntensity[allPM.fromExon,]))
	useInt <- data.frame(probeInt=c(mm.probeInt, pm.probeInt), probeType=c(rep("mm.exon", length(mm.probeInt)),
																																				 rep("pm.exon", length(mm.probeInt))))
	
	plotInt <- rbind(allInt, useInt)
	outPlot <- ggplot(plotInt, aes(x=probeInt, colour=probeType)) + geom_density() + opts(title=inData)
	return(list(outDat=outDat, plot=outPlot))
})
```
     
 Looking at the five human genomes we have:
 * How does the number of probes that align uniquely change in each class of **PM** and **MM**?
   * i.e. for each probe that has a unique alignment in each version of the genome, track whether it:
     * aligns uniquely, aligns non-uniquely, or does not align in each of the other genomes
   * How do we summarize this information in a useful manner?
     * Venn diagrams??