```{r rsetup}
options(stringsAsFactors=FALSE)
require(GenomicRanges)
require(ggplot2)
require(affy)
```

```{r functionDef}
probeClass <- function(probeIDs){
	sapply(strsplit(probeIDs, ".", fixed=T), function(y){y[1]})
}

probeSetName <- function(probeID){
	splitName <- strsplit(probeID, ".", fixed=T)[[1]]
	nSplit <- length(splitName)
	rmSplit <- -1 * c(1, nSplit-1, nSplit)
	paste(splitName[rmSplit], sep=".", collapse=".")
}

sortProbes <- function(probeIDs){
	splitIDs <- strsplit(probeIDs, ".", fixed=T)
	endIndx <- sapply(splitIDs, function(x){
		nEnt <- length(x)
		as.numeric(x[c(nEnt-1, nEnt)])
	})
	endIndx <- t(endIndx)
	order(endIndx[,1], endIndx[,2])
}


```

# Examine Results

## Read in the Saccharomyces cerevisiae data and see what we have

```{r loadSc}

seqLoc <- readBamGappedAlignments("seqData/mappedSequences_sc3.bam", use.names=T)

classSeq <- sapply(strsplit(names(seqLoc), ".", fixed=T), function(x){x[1]})
sum(classSeq == "mm")
```

There is only `r sum(classSeq == "mm")` mismatch probe that aligns to the genome for yeast, so we will ignore yeast from further analysis.

## Check all organisms

```{r countAll}
translationTable <- matrix(ncol=3, byrow=T, data=c("ce6", "Ce", "celegans",
																									 "dm3", "Dm", "drosophila2",
																									 "dr6", "Dr", "zebrafish",
																									 "hg19", "Hs", "hsa",
																									 "mm10", "Mm", "mus",
																									 "rn4", "Rn", "rat",
																									 "sc3", "Sc", "yeast2",
																									 "xt3", "Xt", "xtropicalis"))
colnames(translationTable) <- c("short", "Organism", "array")
bamFile <- file.path("seqData", paste("mappedSequences_", translationTable[,"short"], ".bam", sep=""))
seqFile <- file.path("seqData", paste(translationTable[,"array"], ".pm.mm.RData", sep=""))
nFile <- length(bamFile)
cntDat <- matrix(0, nrow=nFile, ncol=8)
colnames(cntDat) <- c("Organism", "nPair", "map.PM", "map.MM", "dupPM", "dupMM", "singPM", "singMM")

for (iFile in 1:nFile){
	tmpSeq <- readGappedAlignments(bamFile[iFile], use.names=T)
	uniqProbes <- unique(names(tmpSeq))
	tmpClass <- probeClass(uniqProbes)
	cntDat[iFile, "map.PM"] <- sum(tmpClass == "pm") # number of PM probes that align
	cntDat[iFile, "map.MM"] <- sum(tmpClass == "mm") # number of MM probes that align
	
	# remove duplicates first
	allProbes <- names(tmpSeq)
	dupProbes <- unique(allProbes[duplicated(allProbes)])
	
	dupFile <- file.path("seqData", paste("multMatch_", translationTable[iFile,"short"], ".txt", sep=""))
	cat(dupProbes, file=dupFile, sep="\n")
	
	dupClass <- probeClass(dupProbes)
	cntDat[iFile, "dupPM"] <- sum(dupClass == "pm")
	cntDat[iFile, "dupMM"] <- sum(dupClass == "mm")
	
	nonDup <- allProbes[!(allProbes %in% dupProbes)]
	nonClass <- probeClass(nonDup)
	cntDat[iFile, "singPM"] <- sum(nonClass == "pm")
	cntDat[iFile, "singMM"] <- sum(nonClass == "mm")
	
	cntDat[iFile, "Organism"] <- translationTable[iFile, "Organism"]
	
	load(seqFile[iFile])
	cntDat[iFile, "nPair"] <- length(pm.mm.dat$pm)
	rm(pm.mm.dat, tmpSeq)

# 	tmpCnt <- data.frame()
# 	rbind(cntDat)
# 	return(c(nPM=nPM, nMM=nMM, dupPM=dupPM, dupMM=dupMM, nonPM=nonPM, nonMM=nonMM))
}

cntDat <- as.data.frame(cntDat)
write.table(cntDat, file="alignmentCounts.txt", sep="\t", row.names=F, quote=F)
```

So we can basically ignore yeast. However, everything else it looks like we get *some* **MM** alignments. What kinds of questions can we ask with this data?

 * For those **PM** that don't map uniquely, what is the distribution of the # of matches?
 * Same question for the **MM** probes
 * How many **PM** have associated **MM** with perfect matches elsewhere in the genome?
   * How does that change between those **PM** that map uniquely and those that are duplicates?
   * Do those **PM** with **MM** that map to genome have higher intensities?
     * This will require loading multiple **CEL** files for the chip. -> which ones should we use? Should we just take a random sample of the ones available, i.e. one from each condition in a GSE across multiple GSE's??
     * Should we restrict this to **PM** and **MM** that map to exons?
 * Restricting to those probes that map uniquely:
   * Making new probesets based on Refseq, and requiring a minimum of 3 probes per transcript:
     * Again, do we restrict to just exons?
     * How many probesets do we get based on just **PM** probes?
     * How many probesets do we get when including **MM** probes?
     * How many probesets change their composition when **MM** probes are allowed?
     * How do diff. gene results change when **MM** probes are included?
     
## Answer questions above

```{r examinData}
useData <- c("hg19", "dm3", "dr6", "xt3", "rn4", "mm10", "ce6")
celLoc <- c(hg19="hs", mm9="mm", mm10="mm", rn4="rn", dr6="dr", dm3="dm", ce6="ce", xtropicalis="xt")

allData <- lapply(useData, function(inData){
	
	# define functions that will be used later
	
	# For each mismatch that aligned, how many times did it and associated
	getCnts <- function(inData, probeAlign){
		probeNames <- elementMetadata(probeAlign)$probeNames
		allClass <- elementMetadata(probeAlign)$class
		mmAlign <- unique(probeNames[allClass == "mm"])
		mmAlignIndx <- lapply(mmAlign, function(x){which(probeNames %in% x)})
		
		mmAlignSplit <- strsplit(mmAlign, ".", fixed=T)
		pmAlign <- sapply(mmAlignSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmAlignIndx <- lapply(pmAlign, function(x){which(probeNames %in% x)})
		
		allCnts <- data.frame(pm=(sapply(pmAlignIndx, length)), mm=(sapply(mmAlignIndx, length)),
													mmProbe=mmAlign, pmProbe=pmAlign)
		rownames(allCnts) <- NULL
		
		exonFile <- paste(inData, "_mergeExons.bed.gz", sep="", collapse="")
		useExons <- read.table(file.path("seqData", exonFile), sep="\t")
		exonIntervals <- GRanges(seqnames=Rle(useExons[,1]), ranges=IRanges(useExons[,2], useExons[,3]),
											 strand=Rle(useExons[,4]))
		
		exonOverlaps <- subsetByOverlaps(query=probeAlign, subject=exonIntervals, minoverlap=23, type="any")
		
		hasExonProbes <- elementMetadata(exonOverlaps)$probeNames
		exonProbeClass <- elementMetadata(exonOverlaps)$class
		
		mmExons <- unique(hasExonProbes[exonProbeClass == "mm"])
		mmIntIndx <- sapply(mmExons, function(x){which(hasExonProbes %in% x)})
		# figure out the associated PM probes
		mmSplit <- strsplit(mmExons, ".", fixed=T)
		pmExons <- sapply(mmSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmIntIndx <- lapply(pmExons, function(x){which(hasExonProbes %in% x)})
		
		exonCnts <- data.frame(pm=(sapply(pmIntIndx, length)), mm=(sapply(mmIntIndx, length)),
													 mmProbe=mmExons, pmProbe=pmExons)
		rownames(exonCnts) <- NULL
		
		allCnts <- merge(allCnts, exonCnts, by=c("pmProbe", "mmProbe"), all=T, suffixes=c(".A", ".E"))
		
		return(list(allCnts=allCnts, exonIntervals=exonIntervals))
	}
	
	getSignalInt <- function(inData){
		useCel <- file.path("randomCels", celLoc[inData])
		celDat <- ReadAffy(celfile.path=useCel)
		
		bCel <- bg.correct.mas(celDat)
		
		pmIndx <- indexProbes(bCel, which="pm")
		mmIndx <- indexProbes(bCel, which="mm")
		useP <- names(pmIndx)
		
		lenP <- sapply(pmIndx, length) # how many probes in each probeset
		pName <- rep(useP, lenP)
		pmIndx <- unlist(pmIndx, use.names=F)
		pmXY <- indices2xy(pmIndx, abatch=bCel)
		mmIndx <- unlist(mmIndx, use.names=F)
		mmXY <- indices2xy(mmIndx, abatch=bCel)
		
		pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
		mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")
		
		probeNames <- c(pmName, mmName)
		orgName <- c(pmIndx, mmIndx)
		
		nameReord <- order(orgName)
		orgName <- orgName[nameReord]
		probeNames <- probeNames[nameReord]
	
		pIntensity <- rbind(pm(bCel), mm(bCel))
		pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]
	
		all.equal(as.integer(rownames(pIntensity)), orgName)
		rownames(pIntensity) <- probeNames
	
		pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
		n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
		pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]
		
		n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
		pIntensity <- pIntensity[n.affyCtrl,]
		
		indx2Name <- data.frame(indx=orgName, name=probeNames)
		return(list(pIntensity=pIntensity, pm.mm.Corr=pm.mm.Corr)
	}
	
	findNegs <- function(){
		pm.mm.Diff <- pIntensity[pm.mm.Corr$pm,] - pIntensity[pm.mm.Corr$mm,]
		sumNeg <- apply(pm.mm.Diff, 1, function(x){sum(x < 0)})
		
		minSum <- 9
		if (inData == "xtropicalis"){
			minSum <- 2
		} else if (inData == "yeast"){
			minSum <- 6
		}
		
		isNeg <- sumNeg >= minSum
		sum(isNeg) / nrow(pm.mm.Corr)
		pmNeg <- rownames(pm.mm.Diff[isNeg,])
		# of those that show *some* negatives, how many are in our probe lists based on *MM* alignments?
		allPM.fromMM <- allCnts$pmProbe
		nallPM <- length(allPM.fromMM)
		nallPM.inNeg <- sum(allPM.fromMM %in% pmNeg) 
		
		# and just those where the *MM* aligns to an exon?
		fromExon <- !(is.na(allCnts$pm.E))
		allPM.fromExon <- allCnts$pmProbe[fromExon]
		nallPM.Exon <- length(allPM.fromExon)
		nallPM.Exon.inNeg <- sum(allPM.fromExon %in% pmNeg)
		
		allMM.fromExon <- allCnts$mmProbe[fromExon]
		
		outDat <- c(nallPM=nallPM, nallPM.inNeg=nallPM.inNeg, nallPM.Exon=nallPM.Exon, nallPm.Exon.inNeg=nallPM.Exon.inNeg)
		
		return(list(outDat=outDat, pm.mm.Diff=pm.mm.Diff, allMM.fromExon=allMM.fromExon, allPM.fromExon=allPM.fromExon))
	}
	
	# determine correlations between TMmm and MM, and other TM probes
	getCorrelations <- function(mmProbes){
		probeSetID <- sapply(mmProbes, probeSetName)
		nameInt <- rownames(pIntensity)
		classInt <- probeClass(nameInt)
		isMM <- which(classInt == "mm")
		
		
		corDat <- lapply(seq(1, length(mmProbes)), function(iID){
			useID <- probeSetID[iID]
			
			
			isSet <- grep(useID, nameInt)
			qMM <- mmProbes[iID]
			
			mmSet <- nameInt[intersect(isSet, isMM)]
			mmSet <- mmSet[!(mmSet %in% qMM)]
			
			qInt <- matrix(log2(pIntensity[qMM,]), ncol=1)
			sInt <- log2(pIntensity[mmSet,])
			sInt <- t(sInt)
			mmCor <- cor(qInt, sInt)
			
			mmLoc <- which(elementMetadata(singAlign)$probeNames %in% qMM)
			exonHit <- exonOverlaps[exonOverlaps[,1] == mmLoc, 2]
			otherHit <- exonOverlaps[exonOverlaps[,2] == exonHit, 1]
			otherProbes <- elementMetadata(singAlign)$probeNames[otherHit]
			otherProbes <- otherProbes[!(otherProbes %in% qMM)]
			
			if (length(otherProbes) > 3){
				oInt <- log2(pIntensity[otherProbes,])
				oInt <- t(oInt)
				tmCor <- cor(qInt, oInt)
			} else { (tmCor <- NA) }
			
			return(list(mmCor=mmCor, tmCor=tmCor))
	})
	names(corDat) <- mmProbes
	return(corDat)
	}
	#inData <- "dm3" #testing purposes
	{# grab the data we need
	bamFile <- paste("mappedSequences_", inData, ".bam", sep="", collapse="")
	probeAlign <- readGappedAlignments(file.path("seqData", bamFile), use.names=T)
	probeAlign <- as(probeAlign, "GRanges")
	probeNames <- names(probeAlign)
	pClass <- probeClass(probeNames)
	elementMetadata(probeAlign) <- data.frame(probeNames=probeNames, class=pClass) # put probe IDs in here so they don't become mangled
	names(probeAlign) <- NULL
	affyCntr <- unique(grep("AFFX", probeNames, value=T, ignore.case=T))
	keepSeq <- which(!(probeNames %in% affyCntr))
	probeAlign <- probeAlign[keepSeq] 
		
	rm(bamFile, probeNames, pClass, affyCntr, keepSeq)
	}
	
	# commented code chunks that may be useful later
	{ 
# 	mStatus <- duplicated(probeNames)
# 	multProbes <- unique(probeNames[mStatus]) # those probes aligning to multiple locations in the genome
# 	
# 	singProbes <- unique(probeNames[!mStatus])
# 	singSeq <- tmpSeq[which(!mStatus)]
# 	
# 	multClass <- probeClass(multProbes)
# 	pmMult <- multProbes[multClass == "pm"]
# 	mmMult <- multProbes[multClass == "mm"]
	
# 	pmMultCnt <- sapply(pmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	mmMultCnt <- sapply(mmMult, function(x){
# 		sum(allAlign %in% x)
# 	})
# 	
# 	multCnt <- data.frame(cnt=c(pmMultCnt, mmMultCnt), class=c(rep("pm", length(pmMultCnt)), rep("mm", length(mmMultCnt))))
# 	
# 	trimMult <- multCnt[multCnt[,1] <= 10,]
# 	cntMM <- hist(trimMult$cnt[trimMult$class == "mm"], breaks=10, plot=F)
# 	cntPM <- hist(trimMult$cnt[trimMult$class == "pm"], breaks=10, plot=F)
	
	# ggplot(trimMult, aes(x=cnt, colour=class)) + geom_density() + xlim(0, 10)
	
	# because the mm matches are much fewer, it makes far more sense to reverse the question of associations between PM and MM probes, and ask how many of the MM probes that map to the genome have an associated PM match?
	}
	
	# new variables kept: probeAlign
	
	###
	## For each mm probe that had an alignment to the genome, find the associated
	## pm probe and count for both of them how many alignments they had.
	
	# For everything: count the number of alignments to the genome
	{
		probeNames <- elementMetadata(probeAlign)$probeNames
		allClass <- elementMetadata(probeAlign)$class
		mmAlign <- unique(probeNames[allClass == "mm"])
		mmAlignIndx <- lapply(mmAlign, function(x){which(probeNames %in% x)})
		
		mmAlignSplit <- strsplit(mmAlign, ".", fixed=T)
		pmAlign <- sapply(mmAlignSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmAlignIndx <- lapply(pmAlign, function(x){which(probeNames %in% x)})
		
		allCnts <- data.frame(pm=(sapply(pmAlignIndx, length)), mm=(sapply(mmAlignIndx, length)),
													mmProbe=mmAlign, pmProbe=pmAlign)
		rownames(allCnts) <- NULL
		
		rm(allClass, mmAlign, mmAlignIndx, mmAlignSplit, pmAlign, pmAlignIndx)
	}
	
	# New variables kept: probeAlign, allCnts
	
	# restrict to those probes that align to exons
	# Note that these exons are artificial, created using mergeBED to get essentially transcribed regions inside of known genes
	{
		exonFile <- paste(inData, "_mergeExons.bed.gz", sep="", collapse="")
		useExons <- read.table(file.path("seqData", exonFile), sep="\t")
		exonIntervals <- GRanges(seqnames=Rle(useExons[,1]), ranges=IRanges(useExons[,2], useExons[,3]),
											 strand=Rle(useExons[,4]))
		
		exonOverlaps <- subsetByOverlaps(query=probeAlign, subject=exonIntervals, minoverlap=23, type="any")
		
		hasExonProbes <- elementMetadata(exonOverlaps)$probeNames
		exonProbeClass <- elementMetadata(exonOverlaps)$class
		
		mmExons <- unique(hasExonProbes[exonProbeClass == "mm"])
		mmIntIndx <- sapply(mmExons, function(x){which(hasExonProbes %in% x)})
		# figure out the associated PM probes
		mmSplit <- strsplit(mmExons, ".", fixed=T)
		pmExons <- sapply(mmSplit, function(inMM){
			nEl <- length(inMM)
			pmLoc <- as.character(as.integer(inMM[nEl]) - 1)
			paste("pm", paste(inMM[seq(2, nEl-1)], sep=".", collapse="."), pmLoc, sep=".", collapse=".")
		})
		
		pmIntIndx <- lapply(pmExons, function(x){which(hasExonProbes %in% x)})
		
		exonCnts <- data.frame(pm=(sapply(pmIntIndx, length)), mm=(sapply(mmIntIndx, length)),
													 mmProbe=mmExons, pmProbe=pmExons)
		rownames(exonCnts) <- NULL
		
		allCnts <- merge(allCnts, exonCnts, by=c("pmProbe", "mmProbe"), all=T, suffixes=c(".A", ".E"))
		
		rm(exonFile, useExons, exonOverlaps, hasExonProbes, exonProbeClass,
			 mmExons, mmIntIndx, mmSplit, pmExons, pmIntIndx, exonCnts)
	}
	
	# new variables: probeAlign, allCnts, exonIntervals
	
	## Load up the experimental data and rename
	{
		useCel <- file.path("randomCels", celLoc[inData])
		celDat <- ReadAffy(celfile.path=useCel)
		
		bCel <- bg.correct.mas(celDat)
		
		pmIndx <- indexProbes(bCel, which="pm")
		mmIndx <- indexProbes(bCel, which="mm")
		useP <- names(pmIndx)
		
		lenP <- sapply(pmIndx, length) # how many probes in each probeset
		pName <- rep(useP, lenP)
		pmIndx <- unlist(pmIndx, use.names=F)
		pmXY <- indices2xy(pmIndx, abatch=bCel)
		mmIndx <- unlist(mmIndx, use.names=F)
		mmXY <- indices2xy(mmIndx, abatch=bCel)
		
		pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
		mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")
		
		probeNames <- c(pmName, mmName)
		orgName <- c(pmIndx, mmIndx)
		
		nameReord <- order(orgName)
		orgName <- orgName[nameReord]
		probeNames <- probeNames[nameReord]
	
		pIntensity <- rbind(pm(bCel), mm(bCel))
		pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]
	
		all.equal(as.integer(rownames(pIntensity)), orgName)
		rownames(pIntensity) <- probeNames
	
		pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
		n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
		pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]
		
		n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
		pIntensity <- pIntensity[n.affyCtrl,]
		
		indx2Name <- data.frame(indx=orgName, name=probeNames)
		
		rm(celDat, n.affyCtrl, probeNames, orgName, pmName, mmName, useP,
			 lenP, pName, pmIndx, pmXY, mmIndx, mmXY, nameReord)
	}
	
	# new variables: indx2name, pIntensity, pm.mm.Corr, bCel
	
	# calculate how many negatives are the result of mm aligning in genome
	{
		pm.mm.Diff <- pIntensity[pm.mm.Corr$pm,] - pIntensity[pm.mm.Corr$mm,]
		sumNeg <- apply(pm.mm.Diff, 1, function(x){sum(x < 0)})
		
		minSum <- 9
		if (inData == "xtropicalis"){
			minSum <- 2
		} else if (inData == "yeast"){
			minSum <- 6
		}
		
		isNeg <- sumNeg >= minSum
		sum(isNeg) / nrow(pm.mm.Corr)
		pmNeg <- rownames(pm.mm.Diff[isNeg,])
		# of those that show *some* negatives, how many are in our probe lists based on *MM* alignments?
		allPM.fromMM <- allCnts$pmProbe
		nallPM <- length(allPM.fromMM)
		nallPM.inNeg <- sum(allPM.fromMM %in% pmNeg) 
		
		# and just those where the *MM* aligns to an exon?
		fromExon <- !(is.na(allCnts$pm.E))
		allPM.fromExon <- allCnts$pmProbe[fromExon]
		nallPM.Exon <- length(allPM.fromExon)
		nallPM.Exon.inNeg <- sum(allPM.fromExon %in% pmNeg)
		
		allMM.fromExon <- allCnts$mmProbe[fromExon]
		
		outDat <- c(nallPM=nallPM, nallPM.inNeg=nallPM.inNeg, nallPM.Exon=nallPM.Exon, nallPm.Exon.inNeg=nallPM.Exon.inNeg)
		
		rm(sumNeg, minSum, isNeg, pmNeg, nallPM, nallPM.inNeg, fromExon,
		   allPM.fromMM, nallPM.Exon, nallPM.Exon.inNeg)
	}
	
	# new variables are: outDat, pm.mm.Diff, allMM.fromExon, allPM.fromExon
	
	if (outDat["nallPm.Exon.inNeg"] != 0){
	
	# and what about the distribution of probe intensities?
	{
		nSamp <- 10000
		allMMInt <- log2(as.vector(pIntensity[pm.mm.Corr$mm,]))
		allMMInt <- sample(allMMInt, nSamp)
		allPMInt <- log2(as.vector(pIntensity[pm.mm.Corr$pm,]))
		allPMInt <- sample(allPMInt, nSamp)
		allInt <- data.frame(probeInt=c(allMMInt, allPMInt), probeType=c(rep("mm.all", length(allMMInt)), rep("pm.all", length(allPMInt))) )
		
		nMM.fromExon <- length(allMM.fromExon)
	
	
		mm.probeInt <- log2(as.vector(pIntensity[allMM.fromExon,]))
		pm.probeInt <- log2(as.vector(pIntensity[allPM.fromExon,]))
		useInt <- data.frame(probeInt=c(mm.probeInt, pm.probeInt), probeType=c(rep("mm.exon", length(mm.probeInt)),
																																					 rep("pm.exon", length(mm.probeInt))))
		
		allTitle <- inData
		if (inData == "xtropicalis"){
			allTitle <- "xt3"
		}
		
		plotInt <- rbind(allInt, useInt)
		outPlotAllExp <- ggplot(plotInt, aes(x=probeInt, colour=probeType, linetype=probeType)) + geom_density(size=1.5) + labs(title=allTitle, x="log2 probe intensity") + theme_bw()
		rm(plotInt, useInt, mm.probeInt, pm.probeInt, allInt, allPMInt, allMMInt, nSamp,
		 	allMM.fromExon, allPM.fromExon)
		
	}
	
	# For those MM probes that overlap with exons, find the biggest PM - MM difference 
	# and examine some properties
	{
		# do the overlap of exons, because we will use it for every thing later on
		tmpNames <- elementMetadata(probeAlign)$probeNames
		dupNames <- unique(tmpNames[(duplicated(tmpNames))])
		singNames <- tmpNames[!(tmpNames %in% dupNames)]
		singIndx <- which(tmpNames %in% singNames)
		singAlign <- probeAlign[singIndx] # gives only probes that align in one location
		exonOverlaps <- as.matrix(findOverlaps(singAlign, exonIntervals, type="any", minoverlap=23, ))
		
		exonDat <- allCnts[!(is.na(allCnts$pm.E)),] # remember, allCnts is simply for each mapping MM, how often does it map an exon, and how often does its corresponding PM map genome or exon. 
		exonSingleMM <- (exonDat$mm.E == 1) # start with those where the MM aligned to a single exon
		
		if (sum(exonSingleMM) != 0){
			exonDatSingleMM <- exonDat[exonSingleMM,]
			
			mmProbeCor <- getCorrelations(exonDatSingleMM$mmProbe)
			
			exonSingleDifs <- pm.mm.Diff[(exonDat$pmProbe[exonSingleMM]),]
			
			difCut <- -1000
			isNeg <- exonSingleDifs <= difCut
			nNeg <- apply(isNeg, 1, sum)
			
			useDifs <- exonSingleDifs[nNeg > 0, , drop=F]
			
			usePMs <- rownames(useDifs)
			usePMord <- order(usePMs)
			usePMs <- usePMs[usePMord]
			useDifs <- useDifs[usePMord, , drop=F]
			useDat <- exonDatSingleMM[(exonDatSingleMM$pmProbe %in% usePMs), , drop=F]
			useDat <- useDat[(order(useDat$pmProbe)), , drop=F]
			nPMs <- nrow(useDifs)
			
			pmDifDat <- NULL
			
			if (nPMs > 0){
			
				pmDifDat <- vector("list", nPMs)
			
			# common elements for the tiled intensity images
						
			for (iPM in 1:nPMs){
				probeSetP <- probeSetName(usePMs[iPM])
				
				useProbes <- grep(probeSetP, rownames(pIntensity), value=T)
				# set up the data for the probeset, looking at where "our" probes hit
				investigateProbes <- c(useDat$pmProbe[iPM], useDat$mmProbe[iPM]) # the interesting mm and pm
				densityProbes <- useProbes[!(useProbes %in% investigateProbes)]  # all the other probes
				denOrder <- sortProbes(densityProbes) # really critical for zebrafish
				densityProbes <- densityProbes[denOrder]
				
				plot1Title <- paste(investigateProbes, collapse=":")
				plot1Title <- paste("ProbeSetPlot", plot1Title, collapse="\n", sep="\n")
				
				otherPlotTitle <- paste("ExonMatchedPlot", investigateProbes[2], collapse="\n", sep="\n")
				
				# and the probes for the exon that go with the mm probe
				mmLoc <- which(elementMetadata(singAlign)$probeNames %in% investigateProbes[2])
				exonHit <- exonOverlaps[exonOverlaps[,1] == mmLoc, 2]
				otherHit <- exonOverlaps[exonOverlaps[,2] == exonHit, 1]
				otherProbes <- elementMetadata(singAlign)$probeNames[otherHit]
				
				if (length(otherProbes) > 0){
					otherLoc <- singAlign[elementMetadata(singAlign)$probeNames %in% otherProbes]
					if (unique(strand(otherLoc)) == "+"){
						otherLoc <- sort(otherLoc, decreasing=F)
					} else {
						otherLoc <- sort(otherLoc, decreasing=T)
					}
				}
				
				isNeg <- which(useDifs[iPM,] <= difCut)
				celNames <- colnames(useDifs[,isNeg])
				
				nNeg <- length(isNeg)
				
				plotDat <- vector("list", nNeg)
				
				for (iNeg in 1:nNeg){
					
					plot1Title_use <- paste(plot1Title, celNames[iNeg], collapse="\n", sep="\n")
					otherPlotTitle_use <- paste(otherPlotTitle, celNames[iNeg], collapse="\n", sep="\n")
					
					probeSetInt <- pIntensity[densityProbes, isNeg[iNeg]]
					probeSetInt <- data.frame(intensity=(probeSetInt), probeID=names(probeSetInt),
																		probeClass=probeClass(names(probeSetInt)))
					
					investigateInt <- pIntensity[investigateProbes, isNeg[iNeg]]
					investigateInt <- data.frame(intensity=(investigateInt), probeID=names(investigateInt),
																			 probeClass=probeClass(names(investigateInt)),
																			 y=0)
					
					
					bl.Plot1 <- ggplot() + geom_histogram(data=probeSetInt, aes(x=intensity, fill=probeClass), alpha=.5, position="identity") + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass), size=3) + ggtitle(plot1Title_use)
					bl.Plot2 <- ggplot() + geom_density(data=probeSetInt, aes(x=intensity, colour=probeClass, linetype=probeClass)) + geom_point(data=investigateInt, aes(x=intensity, y=y, colour=probeClass, shape=probeClass), size=3) + ggtitle(plot1Title_use) + theme_bw()
					
					
					pm.mm.data <- rbind(probeSetInt, investigateInt[,1:3])
					pm.mm.data$xloc <- unlist(lapply(seq(1,nrow(pm.mm.data)/2), rep, 2))
					pm.mm.data$yloc <- 1
					pm.mm.data$yloc[(pm.mm.data$probeClass == "mm")] <- 2
					pm.mm.data$fill <- sqrt(pm.mm.data$intensity)
					xlim <- 0.5 + c(0, nrow(pm.mm.data)/2)
					
					bl.image <- ggplot(pm.mm.data, aes(x=xloc, y=probeClass, fill=fill)) + geom_tile() + scale_fill_gradient(low="black", high="white", limits=c(0, 256)) + theme(axis.text.x=element_blank(), axis.ticks=element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank()) + coord_equal(ratio=1, xlim=xlim) + ggtitle(plot1Title_use)
 					
					if (length(otherProbes) > 1){
											
						otherInt <- pIntensity[elementMetadata(otherLoc)$probeNames, isNeg[iNeg]]
						otherInt <- data.frame(intensity=otherInt, probeID=names(otherInt), probeClass="tm", xloc=seq(1,length(otherInt)))
						otherInt$fill <- sqrt(otherInt$intensity)
						xlim <- 0.5 + c(0, nrow(otherInt))
						
						tm.image <- ggplot(otherInt, aes(x=xloc, y=probeClass, fill=fill)) + geom_tile() + scale_fill_gradient(low="black", high="white", limits=c(0, 256)) + theme(axis.text.x=element_blank(), axis.ticks=element_blank(), axis.title.x=element_blank(), axis.title.y=element_blank()) + coord_equal(ratio=1, xlim=xlim) + ggtitle(otherPlotTitle_use)
						
						
					} else { 
						tm.image <- NA
						otherInt <- NA
					}
					
			
					plotDat[[iNeg]] <- list(probeSetInt=probeSetInt, investigateInt=investigateInt, pm.mm.Int=pm.mm.data,
																	otherInt=otherInt, histPlot=bl.Plot1, denPlot=bl.Plot2, psImage=bl.image, 
																	exonImage=tm.image)	
					
				}
				pmDifDat[[iPM]] <- list(invProbes=investigateProbes, denProbes=densityProbes, otherProbes=otherProbes,
																exonIndx=exonHit, plotDat=plotDat)
			}
			
		
		}	
	  
	}
	} #end group	
	
	cdf2Det <- grep("cdf", search(), value=T)
	detach(cdf2Det, character.only=T)
	returnDat <- list(pmDifDat=pmDifDat, allPlot=outPlotAllExp, negDat=outDat, mmCor=mmProbeCor,
										exonDat=exonDatSingleMM)
		
	} else {
		returnDat <- list(pmDifDat=NA, allPlot=NA, negDat=outDat, mmCor=NA)
	}
	.sessionInfo <- sessionInfo()
	.timedate <- Sys.time()
	outFile <- paste(inData, "_tmpResults.RData", sep="", collapse="")
	save(.sessionInfo, .timedate, returnDat, file=outFile)
	returnDat
})

names(allData) <- useData
.sessionInfo <- sessionInfo()
.timedate <- Sys.time()
save(.sessionInfo, .timedate, allData, file="counts_Plots_etc_allOrgs.RData")

```

## Allplot of yeast done separately

Because yeast only has one MM that aligns to an exon, we will do its `allPlot` separately.

```{r yeastPlot}
inData <- "sc3"
celLoc <- "yeast"
bamFile <- paste("mappedSequences_", inData, ".bam", sep="", collapse="")
probeAlign <- readGappedAlignments(file.path("seqData", bamFile), use.names=T)
probeAlign <- as(probeAlign, "GRanges")
probeNames <- names(probeAlign)
pClass <- probeClass(probeNames)
elementMetadata(probeAlign) <- data.frame(probeNames=probeNames, class=pClass) # put probe IDs in here so they don't become mangled
names(probeAlign) <- NULL
affyCntr <- unique(grep("AFFX", probeNames, value=T, ignore.case=T))
keepSeq <- which(!(probeNames %in% affyCntr))
probeAlign <- probeAlign[keepSeq]

useCel <- file.path("randomCels", celLoc)
celDat <- ReadAffy(celfile.path=useCel)

bCel <- bg.correct.mas(celDat)

pmIndx <- indexProbes(bCel, which="pm")
mmIndx <- indexProbes(bCel, which="mm")
useP <- names(pmIndx)

lenP <- sapply(pmIndx, length) # how many probes in each probeset
pName <- rep(useP, lenP)
pmIndx <- unlist(pmIndx, use.names=F)
pmXY <- indices2xy(pmIndx, abatch=bCel)
mmIndx <- unlist(mmIndx, use.names=F)
mmXY <- indices2xy(mmIndx, abatch=bCel)

pmName <- paste("pm", pName, pmXY[,1], pmXY[,2], sep=".")
mmName <- paste("mm", pName, mmXY[,1], mmXY[,2], sep=".")

probeNames <- c(pmName, mmName)
orgName <- c(pmIndx, mmIndx)

nameReord <- order(orgName)
orgName <- orgName[nameReord]
probeNames <- probeNames[nameReord]

pIntensity <- rbind(pm(bCel), mm(bCel))
pIntensity <- pIntensity[(order(as.integer(rownames(pIntensity)))),]

all.equal(as.integer(rownames(pIntensity)), orgName)
rownames(pIntensity) <- probeNames

pm.mm.Corr <- data.frame(pm=pmName, mm=mmName) # correspondence between them
n.affyCtrl <- grep("AFFX", pm.mm.Corr$pm, invert=T)
pm.mm.Corr <- pm.mm.Corr[n.affyCtrl,]

n.affyCtrl <- grep("AFFX", rownames(pIntensity), invert=T)
pIntensity <- pIntensity[n.affyCtrl,]

nSamp <- 10000
allMMInt <- log2(as.vector(pIntensity[pm.mm.Corr$mm,]))
allMMInt <- sample(allMMInt, nSamp)
allPMInt <- log2(as.vector(pIntensity[pm.mm.Corr$pm,]))
allPMInt <- sample(allPMInt, nSamp)
allInt <- data.frame(probeInt=c(allMMInt, allPMInt), probeType=c(rep("mm.all", length(allMMInt)), rep("pm.all", length(allPMInt))) )

yeastPlot <- ggplot(allInt, aes(x=probeInt, colour=probeType, linetype=probeType)) + geom_density(size=1.2) + labs(title=inData, x="log2 probe intensity")
allData$sc3 <- list(allPlot=yeastPlot)
.sessionInfo <- sessionInfo()
.timedate <- Sys.time()
save(.sessionInfo, .timedate, allData, file="counts_Plots_etc_allOrgs.RData")
```


## Figures I need to generate:

Tiled output from `allPlot`.

```{r allPlots}
theme_set(theme_bw())
require(Cairo)
allData <- allData[!(names(allData) %in% "mm9")]

plots <- lapply(allData, function(x){x$allPlot})
plots$sc3 <- yeastPlot


nPlot <- length(plots)
useNames <- names(plots)
for (iPlot in 1:nPlot){
	plotFile <- file.path(getwd(), "figures", paste(useNames[iPlot], "_allPlots.svg", sep="", collapse=""))
	print(plotFile)
	#print(useName)
	CairoSVG(file=plotFile)
	tmpPlot <- plots[[iPlot]]
	tmpPlot$layers[[1]]$geom_params$size <- 0.5
	print(tmpPlot)
	dev.off()
}
```
Note that each of these involves modifying the above code. 

For one organism, use `pmDifDat` to demonstrate the difference for one experiment. This will include a tiled intensity
plot with PM on one row and MM on the second row, using `sqrt` transformed intensities. These should be ordered 5' to 
3'.

Similar to the second part of above, but this time with the TM for the exon matching the original MM that mapped to it.

```{r densityDif}
require(ggplot2)
require(Cairo)
dr6 <- list(c(1,1), c(2,6), c(4,1), c(12,2))
xtrop <- list(c(2,1), c(3,4))
rn4 <- list(c(3,8), c(3,5), c(4,2), c(7,2))
hg19 <- list(c(2,2), c(5,1), c(12,1))
mm10 <- list(c(2,4), c(4,1), c(5,1), c(6,1), c(8,4), c(14,10), c(20,2), c(22,2))
ce6 <- list(c(1,18))

tmpDat <- allData$dr6$pmDifDat[[12]]$plotDat[[2]]
CairoSVG(file=file.path("figures/dr6/densityPlot.svg"))
print(tmpDat$denPlot)
dev.off()

CairoSVG(file=file.path("figures/dr6/setPlot.svg"))
print(tmpDat$psImage + theme_grey())
dev.off()

CairoSVG(file=file.path("figures/dr6/tmPlot.svg"))
print(tmpDat$exonImage)
dev.off()

# what is the gene the probeset is annotated to, and what is the gene the exon belongs to?
infoDat <- allData$dr6
mmIndx <- 12
negIndx <- 2

mmName <- infoDat$pmDifDat[[mmIndx]]$invProbes[2]
setName <- probeSetName(mmName)

require("zebrafish.db")
annotRef <- mget(setName, zebrafishREFSEQ, ifnotfound=NA)
annotRef

probeAlign <- readGappedAlignments(file.path("seqData", "mappedSequences_dr6.bam"), use.names=T)
probeAlign <- as(probeAlign, "GRanges")
probeNames <- names(probeAlign)
pClass <- probeClass(probeNames)
elementMetadata(probeAlign) <- data.frame(probeNames=probeNames, class=pClass) # put probe IDs in here so they don't become mangled
names(probeAlign) <- NULL

mmAlign <- probeAlign[(elementMetadata(probeAlign)$probeNames %in% mmName)]

mergeExonsTable <- read.table("seqData/dr6_mergeExons.bed.gz", sep="\t")
mergeExons <- GRanges(seqnames=Rle(mergeExonsTable[,1]), ranges=IRanges(mergeExonsTable[,2], mergeExonsTable[,3]), strand=Rle(mergeExonsTable[,4]))
orgExonsTable <- read.table("seqData/dr6_exons.bed.gz", sep="\t")
orgExons <- GRanges(seqnames=Rle(orgExonsTable[,1]), ranges=IRanges(orgExonsTable[,2], orgExonsTable[,3]), strand=Rle(orgExonsTable[,6]))
elementMetadata(orgExons) <- data.frame(exonID=orgExonsTable[,4])
splitID <- strsplit((elementMetadata(orgExons)$exonID), "_exon")
elementMetadata(orgExons)$refID <- sapply(splitID, function(x){x[1]})

rm(mergeExonsTable, orgExonsTable)

probe2Exons <- as.matrix(findOverlaps(mmAlign, mergeExons, minoverlap=23, type="any"))
useExons <- mergeExons[probe2Exons[,2]]
ref2merge <- as.matrix(findOverlaps(orgExons, useExons, type="within")) # the original exons should be "within" the merged exons
mmGenes <- elementMetadata(orgExons[ref2merge[,1]])$refID

# there is also one PM probe in the probset that appears to have zero intensity, can we see where it maps?

qDat <- infoDat$pmDifDat[[12]]$plotDat[[2]]$pm.mm.Int
pmAll <- qDat[qDat$probeClass == "pm",]
pmLow <- pmAll$probeID[which.min(pmAll$intensity)]
pmAlign <- probeAlign[(elementMetadata(probeAlign)$probeNames %in% pmLow)]
length(pmAlign)
```

Finally, calculate the correlation of the TM(mm) probe with the other MM probes across experiments, and then calculate 
the correlation of the TM(mm) with the other TM probes that match its exon. See how these look for all the exon matching TM(mm) probes for an organism, and see if we can do a full summary for each organism.

```{r allCor}
allData <- allData[!(names(allData) %in% "mm9")]
useName <- names(allData)
corDat <- lapply(useName, function(inN){
	useCor <- allData[[inN]]$mmCor
	mmProbes <- names(useCor)

	nCor <- length(useCor)
	
	mmCor <- data.frame(x=0, y=0, class="", orgName=inN, mmName="")
	tmCor <- data.frame(x=0, y=0, class="", orgName=inN, mmName="")
	
	for (iCor in 1:nCor){
		mmT <- as.vector(useCor[[iCor]]$mmCor)
		mmT <- data.frame(x=as.character(iCor), y=mmT, class="mm", orgName=inN, mmName=mmProbes[iCor])
		mmCor <- rbind(mmCor, mmT)
		
		tmT <- as.vector(useCor[[iCor]]$tmCor)
		if (!(is.na(tmT))){
			tmT <- data.frame(x=as.character(iCor), y=tmT, class="tm", orgName=inN, mmName=mmProbes[iCor])
			tmCor <- rbind(tmCor, tmT)
		}
	}
	
	mmCor <- mmCor[seq(2, nrow(mmCor)),]
	tmCor <- tmCor[seq(2, nrow(tmCor)),]
	
	allCor <- rbind(mmCor, tmCor)
	hasSame <- unique(mmCor$x[(mmCor$x %in% tmCor$x)])
	allCorSame <- allCor[(allCor$x %in% hasSame),]
	return(list(allCor=allCor, allCorSame=allCorSame))
})
names(corDat) <- useName

initCor <- corDat[[1]]$allCorSame
invisible(sapply(corDat[2:length(corDat)], function(x){
	initCor <<- rbind(initCor, x$allCorSame)
}))

initCor$orgName <- as.character(initCor$orgName)
initCor$orgName[(initCor$orgName == "xtropicalis")] <- "xt3"
initCor$class.orgName <- paste(initCor$orgName, initCor$class, sep=":")

CairoSVG(file=file.path("figures", "correlationDif.svg"), width=10, height=6)
ggplot(initCor, aes(x=orgName, y=y, colour=class)) + geom_boxplot() + theme_bw() + labs(x="organism", y="correlation")
dev.off()
```

```{r humanCorrelation}
useCor <- corDat$hg19$allCorSame
mmProbes <- unique(useCor$mmName)

tmV <- useCor$class == "tm"
mmV <- useCor$class == "mm"
tmCor <- sapply(mmProbes, function(x){
	mean(useCor$y[(tmV & (useCor$mmName %in% x))])
})

mmCor <- sapply(mmProbes, function(x){
	mean(useCor$y[(mmV & (useCor$mmName %in% x))])
})

corInfo <- data.frame(tmCor=tmCor, mmCor=mmCor, mmProbe=names(tmCor))
rownames(corInfo) <- NULL
require(hgu133plus2.db)
require(org.Hs.eg.db)

# what are the annotated refseq for the probeset?
corInfo$probeSet <- sapply(corInfo$mmProbe, probeSetName)
annotRefSeq <- mget(corInfo$probeSet, hgu133plus2REFSEQ, ifnotfound=NA)
names(annotRefSeq) <- corInfo$mmProbe
annotRefSeq <- lapply(annotRefSeq, function(x){
	nmVal <- grep("NM", x, value=T)
	nrVal <- grep("NR", x, value=T)
	c(nmVal, nrVal)
}) # get the NMs back


# what is the overlapping refseq for that mismatch probe
inData <- "hg19"
	bamFile <- paste("mappedSequences_", inData, ".bam", sep="", collapse="")
	probeAlign <- readGappedAlignments(file.path("seqData", bamFile), use.names=T)
	probeAlign <- as(probeAlign, "GRanges")
	probeNames <- names(probeAlign)
	pClass <- probeClass(probeNames)
	elementMetadata(probeAlign) <- data.frame(probeNames=probeNames, class=pClass) # put probe IDs in here so they don't become mangled
	names(probeAlign) <- NULL
	affyCntr <- unique(grep("AFFX", probeNames, value=T, ignore.case=T))
	keepSeq <- which(!(probeNames %in% affyCntr))
	probeAlign <- probeAlign[keepSeq] 
		
	rm(bamFile, probeNames, pClass, affyCntr, keepSeq)
	probeAlign <- probeAlign[(elementMetadata(probeAlign)$probeNames %in% corInfo$mmProbe)]

	mergeExonsTable <- read.table("seqData/hg19_mergeExons.bed.gz", sep="\t")
	mergeExons <- GRanges(seqnames=Rle(mergeExonsTable[,1]), ranges=IRanges(mergeExonsTable[,2], mergeExonsTable[,3]), strand=Rle(mergeExonsTable[,4]))
	orgExonsTable <- read.table("seqData/hg19_exons.bed.gz", sep="\t")
	orgExons <- GRanges(seqnames=Rle(orgExonsTable[,1]), ranges=IRanges(orgExonsTable[,2], orgExonsTable[,3]), strand=Rle(orgExonsTable[,6]))
	elementMetadata(orgExons) <- data.frame(exonID=orgExonsTable[,4])
	splitID <- strsplit((elementMetadata(orgExons)$exonID), "_exon")
	elementMetadata(orgExons)$refID <- sapply(splitID, function(x){x[1]})

	rm(mergeExonsTable, orgExonsTable)
	
	probe2Exons <- as.matrix(findOverlaps(probeAlign, mergeExons, minoverlap=23, type="any"))
	ref2merge <- as.matrix(findOverlaps(orgExons, mergeExons, type="within")) # the original exons should be "within" the merged exons
	
probeNames <- elementMetadata(probeAlign)$probeNames
refNames <- elementMetadata(orgExons)$refID	
probe2Ref <- lapply(seq(1, nrow(probe2Exons)), function(inRow){
	useExon <- probe2Exons[inRow,2]
	matchRef <- ref2merge[(ref2merge[,2] == useExon),1]
	refNames[matchRef]
})
names(probe2Ref) <- probeNames[probe2Exons[,1]]

invNames <- names(probe2Ref)
refComp <- lapply(invNames, function(inName){
	aRef <- annotRefSeq[[inName]]
	pRef <- probe2Ref[[inName]]
	aSpec <- aRef[!(aRef %in% pRef)]
	pSpec <- pRef[!(pRef %in% aRef)]
	return(list(aRef=aRef, aSpec=aSpec, pRef=pRef, pSpec=pSpec))
})

names(refComp) <- invNames
corInfo <- corInfo[order(corInfo$mmProbe),]
refComp <- refComp[order(names(refComp))]
corInfo$annotRef <- sapply(refComp, function(x){paste(x$aRef, collapse=", ")})
corInfo$exonRef <- sapply(refComp, function(x){paste(x$pRef, collapse=", ")})
corInfo <- corInfo[,c("tmCor", "mmCor", "probeSet", "mmProbe", "annotRefSeq", "exonRef")]

tmpGene <- vector("list", length(refComp))
for (iGene in 1:length(refComp)){
	aRef <- refComp[[iGene]]$aRef
	if (length(aRef) != 0){
		tmpEnt <- unlist2(mget(aRef, org.Hs.egREFSEQ2EG, ifnotfound=NA))
		tmpSym <- unlist2(mget(tmpEnt, org.Hs.egSYMBOL, ifnotfound=NA))
		useEnt <- unique(names(tmpSym))
		for (iEnt in 1:length(useEnt)){
			tEnt <- useEnt[iEnt]
			names(tmpSym)[names(tmpSym) %in% tEnt] <- unique(names(tmpEnt)[tmpEnt %in% tEnt])
		}
		tmpGene[[iGene]]$aRef <- tmpSym
	}
	
	pRef <- refComp[[iGene]]$pRef
	if (length(pRef) != 0){
		tmpEnt <- unlist2(mget(pRef, org.Hs.egREFSEQ2EG, ifnotfound=NA))
		tmpSym <- unlist2(mget(tmpEnt, org.Hs.egSYMBOL, ifnotfound=NA))
		useEnt <- unique(names(tmpSym))
		for (iEnt in 1:length(useEnt)){
			tEnt <- useEnt[iEnt]
			names(tmpSym)[names(tmpSym) %in% tEnt] <- unique(names(tmpEnt)[tmpEnt %in% tEnt])
		}
		tmpGene[[iGene]]$pRef <- tmpSym
	}
	
}

names(tmpGene) <- names(refComp)
corInfo$aSym <- sapply(tmpGene, function(x){paste(unique(x$aRef), collapse=", ")})
corInfo$pSym <- sapply(tmpGene, function(x){paste(unique(x$pRef), collapse=", ")})
corOut <- corInfo
names(corOut) <- c("tm", "mm", "ProbeSet", "Probe ID", "Annotated RefSeq", "Exon RefSeq", "Annotated Symbol", "Exon Symbol")
corOut <- corOut[order(corOut$tm, decreasing=T),]
write.table(corOut, file="human_mmCorrelations.txt", sep="\t", quote=F, row.names=F, col.names=T)
```
 
 Extra analysis: For each organism, find the biggest negative difference, and for that particular
 experiment and probeset, look at the signal distributions of the PM probes and MM probes (without the MM probe that caused problem), and look at where the MM probe falls in the distribution. How does the summarization value change with and without thise PM-MM pair? 
 Then define a new probeset based on the exon the MM probe aligns to, and look at the PM signal distribution and where the MM probe intensity now falls. What is the summary value for this probeset with and without the MM probe?
 Looking at the five human genomes we have:
 * How does the number of probes that align uniquely change in each class of **PM** and **MM**?
   * i.e. for each probe that has a unique alignment in each version of the genome, track whether it:
     * aligns uniquely, aligns non-uniquely, or does not align in each of the other genomes
   * How do we summarize this information in a useful manner?
     * Venn diagrams??